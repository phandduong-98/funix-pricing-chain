{
  "language": "Solidity",
  "sources": {
    "contracts/Main.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Session.sol\";\r\nimport \"./SharedStruct.sol\";\r\n\r\ncontract Main {\r\n\r\n    address[] public participantKeys;\r\n    mapping(address => Participant) public participants;\r\n    mapping(address => bool) public isSession;\r\n    //The smart contract should contain the hash of all the pricing sessions.\r\n    Session[] public sessions;\r\n\r\n    // The account deployed the main smart contract will be set as admin account\r\n    // contract address vs address\r\n    address public admin;\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n    modifier validParticipant() {\r\n        require(participants[msg.sender].account != address(0), \"Not registered\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySessionContract() {\r\n        require(isSession[msg.sender] == true, \"Not session\");\r\n        _;\r\n    }\r\n\r\n    function createNewSession(\r\n        string memory _productName,\r\n        string memory _productDescription,\r\n        string[] memory _productImages,\r\n        uint256 _sessionDuration\r\n    ) external onlyAdmin returns (Session) {\r\n        Session newSession = new Session(\r\n            address(this),\r\n            admin,\r\n            _productName,\r\n            _productDescription,\r\n            _productImages,\r\n            0,\r\n            0,\r\n            _sessionDuration\r\n        );\r\n        sessions.push(newSession);\r\n        isSession[address(newSession)] = true;\r\n        return newSession;\r\n    }\r\n\r\n    function register(string memory _fullName, string memory _email)\r\n        external\r\n        returns (bool)\r\n    {\r\n        //only for address that has not registered\r\n        require(participants[msg.sender].account == address(0));\r\n        Participant memory newParticipant = Participant({\r\n            account: msg.sender,\r\n            fullName: _fullName,\r\n            email: _email,\r\n            numberOfJoinedSession: 0,\r\n            deviation: 0\r\n        });\r\n\r\n        participants[msg.sender] = newParticipant;\r\n        participantKeys.push(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function updateParticipantDeviation(address _account, uint256 _deviation)\r\n        external\r\n        onlySessionContract()\r\n    {\r\n        participants[_account].deviation = _deviation;\r\n    }\r\n\r\n    function incrementParticipantNumberOfSession(address _account)\r\n        external\r\n        onlySessionContract()\r\n    {\r\n        participants[_account].numberOfJoinedSession += 1;\r\n    }\r\n\r\n    function checkRegistered()\r\n        external\r\n        view\r\n        validParticipant\r\n        returns (address)\r\n    {\r\n        return msg.sender;\r\n    }\r\n\r\n    function getParticipants()\r\n        external\r\n        view\r\n        onlyAdmin\r\n        returns (Participant[] memory)\r\n    {\r\n        Participant[] memory _participants = new Participant[](\r\n            participantKeys.length\r\n        );\r\n        for (uint256 i = 0; i < participantKeys.length; i++) {\r\n            Participant memory participant = participants[participantKeys[i]];\r\n            _participants[i] = participant;\r\n        }\r\n        return _participants;\r\n    }\r\n\r\n    function getParticipant()\r\n        external\r\n        view\r\n        validParticipant\r\n        returns (Participant memory)\r\n    {\r\n        return participants[msg.sender];\r\n    }\r\n\r\n    function updateSessionDetail(\r\n        address _sessionAddress,\r\n        string memory _productName,\r\n        string memory _productDescription,\r\n        string[] memory _productImages\r\n    ) public onlyAdmin {\r\n        Session _session = Session(_sessionAddress);\r\n        _session.updateSessionDetail(\r\n            _productName,\r\n            _productDescription,\r\n            _productImages\r\n        );\r\n    }\r\n\r\n    function getSessions() external view returns (SessionDetail[] memory) {\r\n        SessionDetail[] memory _sessionsDetail = new SessionDetail[](\r\n            sessions.length\r\n        );\r\n\r\n        for (uint256 i = 0; i < sessions.length; i++) {\r\n            SessionDetail memory sessionDetail = sessions[i].getSessionDetail();\r\n            _sessionsDetail[i] = sessionDetail;\r\n        }\r\n        return _sessionsDetail;\r\n    }\r\n\r\n    function updateParticipantDetail(\r\n        string memory _fullName,\r\n        string memory _email\r\n    ) public validParticipant {\r\n        participants[msg.sender].fullName = _fullName;\r\n        participants[msg.sender].email = _email;\r\n    }\r\n}\r\n"
    },
    "contracts/Session.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Main.sol\";\r\nimport \"./SharedStruct.sol\";\r\n\r\ncontract Session {\r\n    /*     \r\n    The Smart contract instance will maintain:\r\n    - Product name\r\n    - Product description\r\n    - A list of hash that refer to Product images stored on IPFS.\r\n    - List of participants\r\n    - All given price of participants\r\n    - The proposed price (calculated based on all given price and participants’ deviation)\r\n    - The final price (get updated when the session end)\r\n    - State of pricing session \r\n*/\r\n\r\n    string public productName;\r\n    string public productDescription;\r\n    string[] productImages;\r\n    address[] public sessionParticipants;\r\n    mapping(address => uint256) public sessionProposes;\r\n    uint256 public proposedPrice;\r\n    uint256 public finalPrice;\r\n    address public admin;\r\n    Main public mainContract;\r\n    State public state; //\r\n\r\n    // //timer\r\n    uint256 private immutable i_startTime;\r\n    uint256 private sessionDuration;\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin\");\r\n        _;\r\n    }\r\n    modifier onlyMainContract() {\r\n        require(msg.sender == address(mainContract), \"Only main contract\");\r\n        _;\r\n    }\r\n\r\n    modifier validState(State _expectedState) {\r\n        require(state == _expectedState, \"Wrong state\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyRegistered() {\r\n        (address _account, , , , ) = mainContract.participants(msg.sender);\r\n        require(_account != address(0), \"Not registered\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _mainContract,\r\n        address _admin,\r\n        string memory _productName,\r\n        string memory _productDescription,\r\n        string[] memory _productImages,\r\n        uint256 _proposedPrice,\r\n        uint256 _finalPrice,\r\n        uint256 _sessionDuration\r\n    ) {\r\n        mainContract = Main(_mainContract);\r\n        admin = _admin;\r\n        proposedPrice = _proposedPrice;\r\n        productName = _productName;\r\n        productDescription = _productDescription;\r\n        productImages = _productImages;\r\n        finalPrice = _finalPrice;\r\n        state = State.OPENED;\r\n        // //initialize timer\r\n        i_startTime = block.timestamp;\r\n        sessionDuration = _sessionDuration;\r\n    }\r\n\r\n    // cần update # session join ngay lần đầu propose???\r\n    // sessionDuration = 0 => no time limit for session => admin need to close session\r\n    // sessionDuration > 0 => time limit for session => can only propose in time limit\r\n    // let user change state???\r\n    // flow : if sessionDuration = 0 => no require time limit else require time limit\r\n    function propose(uint256 _price)\r\n        external\r\n        onlyRegistered\r\n        validState(State.OPENED)\r\n    {\r\n        require(_price > 0, \"Price must greater than 0\");\r\n        require(\r\n            sessionParticipants.length < 10,\r\n            \"Participants need to be less than 10\"\r\n        );\r\n        if(sessionDuration > 0){\r\n            require(block.timestamp <= i_startTime + sessionDuration, \"Session is closed\");\r\n        }\r\n\r\n        sessionProposes[msg.sender] = _price;\r\n        sessionParticipants.push(msg.sender);\r\n        proposedPrice = calculateProposedPrice();\r\n    }\r\n\r\n    function calculateProposedPrice() public view returns (uint256) {\r\n        require(sessionParticipants.length > 0, \"No participant\");\r\n\r\n        uint256 numerator;\r\n        uint256 denumerator;\r\n        uint256 totalDeviation;\r\n\r\n        for (uint256 i = 0; i < sessionParticipants.length; i++) {\r\n            (, , , , uint256 currentDeviation) = mainContract.participants(\r\n                sessionParticipants[i]\r\n            );\r\n            if (currentDeviation > 100 * 10**18) {\r\n                currentDeviation = 100 * 10**18;\r\n            }\r\n            numerator =\r\n                numerator +\r\n                (sessionProposes[sessionParticipants[i]]) *\r\n                (100 * 10**18 - (currentDeviation));\r\n            totalDeviation = ((totalDeviation) + (currentDeviation));\r\n        }\r\n        denumerator =\r\n            (100 * sessionParticipants.length) *\r\n            10**18 -\r\n            (totalDeviation); //100*3 - 200\r\n        if (denumerator == 0) return 0;\r\n        return numerator / denumerator;\r\n    }\r\n\r\n    function calculateParticipantNewdeviation(uint256 _participantSessionPrice)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(finalPrice > 0);\r\n        uint256 diff = finalPrice >= _participantSessionPrice\r\n            ? (finalPrice - _participantSessionPrice)\r\n            : (_participantSessionPrice - finalPrice);\r\n        return (((diff * 100) * 10**18) / finalPrice);\r\n    }\r\n\r\n    function calculateParticipantAccumulatedDeviation(\r\n        uint256 _currentDeviation,\r\n        uint256 _numberOfJoinedSession,\r\n        uint256 _newDeviation\r\n    ) internal pure returns (uint256) {\r\n        return\r\n            (_currentDeviation * _numberOfJoinedSession + _newDeviation) /\r\n            (_numberOfJoinedSession + 1);\r\n    }\r\n\r\n    function afterClosingSession(uint256 _finalPrice)\r\n        external\r\n        onlyAdmin\r\n        // validState(State.CLOSING)\r\n        validState(State.OPENED)\r\n    {\r\n        require(_finalPrice >= 0);\r\n        state = State.CLOSED;\r\n\r\n        finalPrice = _finalPrice;\r\n        // calculate and update dnew + accumulated deviation\r\n        for (uint256 i = 0; i < sessionParticipants.length; i++) {\r\n            // address currentParticipationAddress = sessionParticipants[i];\r\n            (\r\n                ,\r\n                ,\r\n                ,\r\n                uint256 _numberOfJoinedSession,\r\n                uint256 _deviation\r\n            ) = mainContract.participants(sessionParticipants[i]);\r\n\r\n            uint256 newDeviation = calculateParticipantNewdeviation(\r\n                sessionProposes[sessionParticipants[i]]\r\n            );\r\n\r\n            uint256 accumulatedDeviation = calculateParticipantAccumulatedDeviation(\r\n                    _deviation,\r\n                    _numberOfJoinedSession,\r\n                    newDeviation\r\n                );\r\n\r\n            mainContract.updateParticipantDeviation(\r\n                sessionParticipants[i],\r\n                accumulatedDeviation\r\n            );\r\n\r\n            mainContract.incrementParticipantNumberOfSession(\r\n                sessionParticipants[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function getFinalPrice() external view returns (uint256) {\r\n        return finalPrice;\r\n    }\r\n\r\n    function updateSessionDetail(\r\n        string memory _productName,\r\n        string memory _productDescription,\r\n        string[] memory _productImages\r\n    ) external onlyMainContract validState(State.OPENED) {\r\n        productName = _productName;\r\n        productDescription = _productDescription;\r\n        productImages = _productImages;\r\n    }\r\n\r\n    function getSessionDetail() external view returns (SessionDetail memory) {\r\n        SessionDetail memory _sessionDetail = SessionDetail({\r\n            sessionAddress: address(this),\r\n            productName: productName,\r\n            productDescription: productDescription,\r\n            productImages: productImages,\r\n            finalPrice: finalPrice,\r\n            proposedPrice: proposedPrice,\r\n            state: state\r\n        });\r\n        return _sessionDetail;\r\n    }\r\n\r\n    function getStartTime() external view returns (uint256) {\r\n        return i_startTime;\r\n    }\r\n\r\n    function getSessionDuration() external view returns (uint256) {\r\n        return sessionDuration;\r\n    }\r\n\r\n\r\n}\r\n"
    },
    "contracts/SharedStruct.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nenum State {\r\n    OPENED,\r\n    CLOSED\r\n}\r\n\r\nstruct Participant {\r\n    address account;\r\n    string fullName;\r\n    string email;\r\n    uint256 numberOfJoinedSession;\r\n    uint256 deviation;\r\n}\r\n\r\nstruct SessionDetail {\r\n    address sessionAddress;\r\n    string productName;\r\n    string productDescription;\r\n    string[] productImages;\r\n    uint256 finalPrice;\r\n    uint256 proposedPrice;\r\n    State state;\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}